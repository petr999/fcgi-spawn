#!/usr/bin/perl


package main;
use strict;
use warnings;

my( $config_path, $pid_file, $log_file, $user, $group, $redefine_exit, ); my $preload = 0;

unless( scalar @ARGV ){ print "Usage help: $0 -h\n"; CORE::exit;
}
while( my $arg0 = shift @ARGV ){
	if			( $arg0 eq '-c' 	){ $config_path 					= shift @ARGV;
	} elsif	( $arg0 eq '-p' 	){ $pid_file 							= shift @ARGV;
	} elsif	( $arg0 eq '-l' 	){ $log_file 							= shift @ARGV;
	} elsif	( $arg0 eq '-u' 	){ $user 									= shift @ARGV;
	} elsif	( $arg0 eq '-g' 	){ $group 								= shift @ARGV;
	} elsif	( $arg0 eq '-s' 	){ $ENV{FCGI_SOCKET_PATH} = shift @ARGV;
	} elsif	( $arg0 eq '-e' 	){ $redefine_exit = 1;
	} elsif	( $arg0 eq '-pl' 	){ $preload = 1;
	} elsif	( grep { $arg0 eq $_ }( '-h', '-?', ) ){
		print "Usage:\n\t-h, -?\t\tdisplay this help\n\t-c <config path>\tpath to the config file(s)\n\t-l\t\tlog file\n\t-p\t\tpid file\n"
					."\t-u\t\tsystem user name\n\t-g\t\tsystem group name\n\t-s\t\tsocket name with full path\n"
					."\t-e\t\tredefine exit builtin perl function\n\t-pl\t\tevaluate the preload scripts\n";
		CORE::exit;
	}
}

BEGIN{
  $ENV{FCGI_SOCKET_PATH} = "/tmp/spawner.sock" unless defined $ENV{FCGI_SOCKET_PATH};
	if( grep { '-e' eq $_  } @ARGV ){
		my $cref = sub {
			if( 'FCGI::ProcManager' eq scalar caller ){
				CORE::exit @_;
			} else {
				last CALLED_OUT;
			}
		};
		*CORE::GLOBAL::exit = $cref;
		*CORE::GLOBAL::exit;
	}
}

use POSIX qw/setuid setgid setsid/;

if( $redefine_exit ){
	use subs qw/exit/ ;
}




defined( my $pid = fork ) or die "Forking logger: $!";
if( $pid ){
  if( defined $pid_file ){
    open( PIDF, ">$pid_file" ) or die "Writing $pid_file: $!";
    print PIDF "$pid\n"; close PIDF;
  }
	CORE::exit;
}


sub re_open_log{
	my $log_file = shift;
  close FCGI_SPAWN_LOG if defined fileno FCGI_SPAWN_LOG;
  open( FCGI_SPAWN_LOG, ">>$log_file" ) or die "Opening log $log_file: $!";
  *STDOUT = *FCGI_SPAWN_LOG; *STDERR = *FCGI_SPAWN_LOG;
  open STDIN, '/dev/null'   or die "Can't read /dev/null: $!";
}

re_open_log $log_file;
$SIG{ USR1 } = sub{ re_open_log( $log_file ); };


defined( my $spawn_pid = fork ) or die "Forking spawn: $!";
if( $spawn_pid ){
  map{ my $signal = $_; $SIG{ $signal } = sub{
		kill $signal, $spawn_pid ; 
		#	if( $signal eq 'TERM' ){
		#		CORE::exit ; 
		#	}
	};
  } qw/HUP TERM/;
	$0 = 'fcgi_spawn';
	waitpid $spawn_pid, 0;
	unlink $pid_file;
	CORE::exit;
}

my $gid = getgrnam( $group ); die "Get group $group: $!" if $gid == 0; 
setgid( $gid ); $) = $gid; $( = $gid; die "Set group $group($gid): $!" if ( $( != $gid ) or ( $) != $gid );
my $uid = getpwnam( $user ); die "Get user $user: $!" if $uid == 0;
setuid( $uid ); $> = $uid; $< = $uid; die "Set user $user($uid): $!" if ( $< != $uid ) or ( $> != $uid );

setsid or die "Setting session: $!";
%ENV=();


my $config_file = "$config_path/fcgi_spawn.conf"; my $conf = {};
open( FCGI_CONFIG, "<$config_file" ) or die "Opening $config_file: $!";
while( <FCGI_CONFIG> ){
	next if /^\s*(#|$)/;
	chomp; s/^\s+//g;
	if( my( $key, @val ) = split /\s+/, $_ ){
		if( 1 < scalar @val  ){
			$conf->{ $key } = \@val ;
		} else {
			$conf->{ $key } = shift @val ;
		}
	}
}
close FCGI_CONFIG;

eval "use FCGI::Spawn;"; die $@ if $@;

$conf->{ sock_chmod } = oct( $conf->{ sock_chmod }  )or die "Not a chmod for socket: ". $conf->{ sock_chmod }  ;

my $spawn = FCGI::Spawn->new( $conf, );

my $preloaders = { nonprepared => [], prepared => [], };
if( $preload ){
  opendir( my $preloaders_dh, $config_path ) or die "Opening path $config_path: $!";
  while( my $fn = readdir $preloaders_dh ){
  	next if grep { $_ eq $fn } qw/. ../;
		my $full_fn = join '/', $config_path, $fn;
		next unless -f $full_fn;
  	push( @{ $preloaders->{ nonprepared  } }, $full_fn ) if $fn =~ /^preload_nonprepared_\d+\.pl$/;
  	push( @{ $preloaders->{ prepared  } }, 		$full_fn ) if $fn =~ /^preload_prepared_\d+\.pl$/;
  }
  closedir $preloaders_dh;


  map{
  	$preloaders->{ $_  } = [
  		map{
  			my $str = '';
  			open( PRELOADER, "<$_" ) or die "Open $_: $!";
  			while( <PRELOADER> ){
  			  $str .= $_; 
  			}
  			close PRELOADER;
  			$str;
  		} sort { 
  			my( $anum, $bnum ) = map{
  				my $c = $_; $c =~ s/[^\d]//g;
  				$c;
  			} ( $a, $b );
  			$anum <=> $bnum;
  		} @{ $preloaders->{ $_  } }
  	];
  } keys %$preloaders;
  
  
  map{ eval $_; die $@ if $@;
  } @{ $preloaders->{ nonprepared } };

}

$spawn->prepare;


if( $preload ){
  map{ eval $_; die $@ if $@;
  } @{ $preloaders->{ prepared } };
}


$spawn -> spawn; 

1;
