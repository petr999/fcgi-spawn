#!/usr/bin/perl

package main;

use strict;
use warnings;

=pod

=head1 NAME

fcgi_spawn - C<FastCGI> server for C<CGI>-like Perl applications effective multiprocessing, the executable daemon of FCGI::Spawn

=head1 DESCRIPTION

Daemon enables you to launch Perl applications originally written for C<CGI> environment. To accomplish C<POST> input you should need to patch your C<CGI.pm> with the patch supplied in the C<FCGI::Spawn> distribution, or the application, in some rare cases (like the Bugzilla), the both.
Daemon is intended to be launched  as a root ( C<uid = 0> ) user, although you may run it as a target user itself.
You need the C<FastCGI>-capable web server capable to work with other ('external') daemons by a C<FastCGI> protocol: the 'C<FastCGI> requester'.
Many features supported like the fine-tune on the number of processes, maximum number of requests served by the each process in its lifetime, more on this on L<FCGI::Spawn>, also L<tested environments|FCGI::Spawn/"Tested Environments"> and comparison to the well-known L<Perl runtime environments|FCGI::Spawn/"Why not mod_perl/mod_perl2/mod_fcgid?">.
Main focus of the daemon is the system administration convenience and adaptation to the OS distribution(s), as it is seen from:

=head1 SYNOPSIS

The necessary configuration for fcgi_spawn is to be located in the dedicated directory, specified by -c command line parameter (by default the /usr/local/etc for C<FreeBSD>/C<Slackware> packages; /etc for C<FHS>-compatible Linux/C<Cygwin> packages ( C<RedHat>, Debian, etc. ) . This includes the configuration file C<fcgi_spawn.conf>, and optional preload scripts aimed similarly as the C<startup.pl> of the mod_perl: to preload the modules before the process to fork, and perform necessary initialization steps like environment variables setup.

=head2 Command line options

Consider all of them to be mandatory:

  -c <config_path> Full path to the directory of configuration file, the
fcgi_spawn.conf ( See 'Configuration File' below );
  -p <pid_file>    Full path and name of the process ID file name;
  - Either of these two:
    -l <log_file>    Full path and name  of the log file name, or:
    -nd              do not detach from console
  -u <user>         Name of the system user to run the FastCGI applications;
  -g <group>        Name of the system group to run the FastCGI applications;
  -s <socket>       Name of the local UNIX socket to be created by the daemon to
                    listen for incoming connections. You should try :number or
                    a.dd.re.ss:number or ho.st:number as a value of this
                    option in the case the TCP connectivity is wanted;

Those are optional:

  -e                Redefine the exit() Perl builtin function to prevent the
                    spawned persistent processes from exiting and starting
                    again when your application(s) exit;
  -t NN             set callout time limit to NN seconds ( 60 by default,
                    0 disables the feature );
  -stl              wait NN seconds for called out process to terminate by
                    time limit before kill it ( 1 by default, 0 disables the
                    feature );
  -mmf              name of the lock file for the -t feature ( defaults to
                    /tmp/fcgi_spawn_scoreboard.lck );
  -mms              size of the shared memory segment for the -t feature 
                    ( defaults to 65535 bytes );
  -cm               validate config file by means of L<Moose>. Use this if your
                    scripts use Moose or if you can spend your memory for this.
  -pl               Evaluate the:

=head2 C<Preload> Scripts from the configuration directory

You can use C<preload> scripts for modules C<preload> and initialization, similarly to the what is the Apache's C<startup.pl> is attended for in the mod_perl's world , although C<fcgi_spawn> doesn't execute them from the root ( C<uid = 0> ) user. ( while apache does ).
Typically, good results are achieved when you try to execute the dummy index page of the web application in them, because it loads the most necessary modules of the application. If you have no errors when execute that perl script ( obviously C<index.pl> or C<index.cgi> depending on your application ) as a C<fcgi_spawn>'s target user and group ( specified with C<-u> and C<-g> options ), you should give it a try. Thing to beware at this point is: environment variables cause C<fcgi_spawn> clears the all of the environment for security purposes.

C<Preload> scripts are to be located in the configuration directory with the names C<preload_nonprepared_NN.pl> and C<preload_prepared_MM.pl>, respectively. The C<NN> and C<MM> here mean a number of the execution sequence, as you may wish to C<use SomeModule> on the followed of scripts and have its functionality on the scripts following after those. The difference between non- and C<prepared> scripts is: the multi-processing occurs to happen in between of them ( L<FCGI::Spawn/prepare> ). That means that the C<'nonprepared'> scripts are the best place to C<preload> your applications' modules, but the I<handles> like the data files, sockets, database handles, etc. can exist only per single process and therefore should be established in the 'prepared' scripts.

Predefined symbols for C<preload> scripts are:

=over

=item $spawn

the L<FCGI::Spawn|FCGI::Spawn> object.

It is useful to do the trick like this for your C<CGI> C<app>:

        $FCGI::Spawn::fcgi = new CGI;
        $spawn->callout( '/path/to/your/CGI/app.pl', $FCGI::Spawn::fcgi );
        undef $FCGI::Spawn::fcgi;

( C<CGI.pm.patch> supplied in the source package is required for this to work best. )
This loads the most of your application's code into memory in the C<'nonprepared'> script before the daemon to fork() which is the main to know about what the L<FCGI::Spawn's prepare|FCGI::Spawn/prepare> is.

=item CALLED_OUT

the label to go to with the exit() Perl builtin redefined ( '-e' command line parameter ).

Should be contained in the code reference supplied as a L<callout|FCGI::Spawn/new({hash parameters})> property of the $spawn, the C<FCGI::Spawn object>. This is to keep the exit()'ed C<CGI> application from exiting the C<FastCGI> connection C<accept()> loop before C<max_requests> processed. The code use this label like this:

        $spawn->{ callout } =  sub{ do shift;
        CALLED_OUT: eval ' $Bugzilla::_request_cache = { }; '
          if defined( $Bugzilla::_request_cache ) and scalar keys %{ $Bugzilla::_request_cache };
        };

=item $OURS

Hash reference to keep scalar variables in between preload eval()s. Those are to be restored in preload scripts like this:

        map{ ${ $main::{ $_ } }
              = $OURS->{  $_ } ;
        } qw/webguiRoot bugzillaRoot skybillRoot/;

=back

All of the preload scripts, if any exist, are eval()'ed after the C<$spawn> is initialized with the values from:

=head2 Configuration File

C<fcgi_spawn.conf>, to be read from the configuration directory specified with C<-c> command line parameter, should contain the values of the L<FCGI::Spawn|FCGI::Spawn> object constructor, method "L<new|FCGI::Spawn/new>", if those need to differ from the defaults. The exception is the C<callout> parameter which is not a constant but the CODE reference and should be set up in the C<preload_noprepared> scripts.

Syntax is: spaces and tabs at the begin of the line are ignored, the C<#> symbol before the rest means this line is ignored as a comment too, key and value are separated with the space(s) or tab(s) all on the same line, and if the value is multiple ( same way separated ) values, it is treated as an array reference ( wanted for C<sock_chown> parameter ).

Sample configuration file, C<fcgi_spawn.conf.sample>, is provided in the source distribution.

=head1 Typical C<CGI> Applications with C<fcgi_spawn>

C<FCGI::Spawn>, and therefore C<fcgi_spawn>, are able to work in Unix and Cygwin environments, with 'properly' written C<CGI> applications, which the most of the well-known C<CGI> applications are. This means: no much assign of the global variables, incapsulation of the code in the C<Namespace::sub()>s at least, and so on.

Care should be taken about file and database handles closing and networking sockets disconnection because the C<END{}> block of your Perl application is unlikely to be executed automatically, like it does in true C<CGI> application. You should refer to C<Mod_Perl> code guides in Chapter 6 of Practical mod_perl book: L<http://modperlbook.org/pdf/ch06.pdf> Commonly, if your C<CGI> application runs well with the typical C<PerlRun> and C<Registry> environments of the C<Mod_Perl>, it should with the C<fcgi_spawn> ( and C<CGI.pm.patch> supplied ), too. At least as the examples below do:

=head2 C<WebGUI.org>

Till version 6.9 supported C<CGI> mode, requires the 'date' system command to be present in the PATH. Fix this in preload script. You should C<preload_nonprepared> your C<index.pl> with the C<$spawn>'s ->L<callout|FCGI::Spawn/callout>, too. Demo is: L<http://alpha.vereshagin.org>.

=head2 C<Skybill>

Traffic accounting system was rewritten a bit, as you can see from L<http://skybill.sf.net>. It was ( and in many aspects is ) my old dummy code but it's to show that even that is able to be C<fcgi_spawn>-friendly. You may want to use the L</FCGI::Spawn/xinc> feature not only to cache the C<XSLT> object between request but to share it among fork()ed processes, it is accomplished with C<callout> of the C<index.pl> on your C<preload_nonprepared> script automatically. Demo is: L<http://skybill.vereshagin.org>.

=head2 C<Bugzilla>

Got to know satisfaction: this was probably a worst evil code ever seen. Despite it has no problems with C<mod_perl>, that required many tricks to perform and here is the scoop:

=over

=item Many exit()s on the blocks

Requires the exit() to be redefined with C<-e> command line switch for C<fcgi_spawn>, and the C<CALLED_OUT> label to be crafted like it is already described here.

=item C<CGI.pm> inheritance

Required the both patches to be applied, on C<CGI.pm> and C<Bugzilla/CGI.pm>, or the C<mod_perl> feature turned on, see the "Configuration File" below.

=item Request caching

C<Bugzilla>'s own request cache cleans only if the C<mod_perl> is used specifically. Same about the C<CALLED_OUT> here.

=item Environment cleaning

As an evil of L<Date::Manip|Date::Manip> ( I myself hate it too, since the C<DateTime.pm> infrastructure is much better ), and thus the C<WebGUI.org> too, the C<Bugzilla> can make your system commands unavailable from your applications on your PATH environment variable. This is why you should also enable the C<save_env> feature on C<fcgi_spawn.conf>, if it is not enabled in L<FCGI::Spawn|FCGI::Spawn> by default.

Also, in some cases the C<Bugzilla>'s C<CGI> programs use to take $0 instead of $ENV{ SCRIPT_NAME } which makes the URLs generated pointless.

=back

Demo is located at:

=head1 BUGS And TODOs

L<http://bugs.vereshagin.org/product/FCGI%3A%3ASpawn>

Adequate reports are accepted.

=head1 Runtime Control

Daemon is supplied with POSIX signal handling: C<USR1> makes it to reopen the log file, and every other signal is passed as is to the actual L<FCGI::ProcManager|FCGI::ProcManager> process.

=head1 LICENSE

C<LGPL>, as of the MANIFEST file in L<FCGI::Spawn|FCGI::Spawn>'s CPAN distribution. More info on fcgi_spawn at: L<http://fcgi-spawn.sf.net>.

=cut

use POSIX qw/setuid setgid setsid :sys_wait_h WNOHANG/;

use Sub::Name;
use Carp;
use FCGI::Spawn::BinUtils ':scripts';

our $OURS = {};
my( $config_path, $pid_file, $log_file, $user, $group, $redefine_exit, );
my( $preload, $no_detach, $time_limit, $soft_tl, $conf_moose )
  = ( 0, 0, 60, 1, 0, );
my( $mm_file, $mm_size ) = ( '/tmp/fcgi_spawn_scoreboard.lck', 65535 );
my $argv_lookup = {
  'c' => \$config_path, 'p' => \$pid_file, 'l' => \$log_file, 'u' => \$user,
  'g' => \$group,
  's' => \$ENV{FCGI_SOCKET_PATH},
  't' => subname( 'time_limit_init' => sub{ $time_limit = shift @ARGV; }, ),
  'stl' => subname( 'soft_tl_init' => sub{ $soft_tl = shift @ARGV; }, ),
  'e' => [ \$redefine_exit => 1, ], 'pl' => [ \$preload => 1, ],
  'nd' => [ \$no_detach => 1, ],
  'h' => \&print_help_exit,
  'mmf' => \$mm_file, 'mms' => \$mm_size, 'cm' => [ \$conf_moose => 1, ],
};
$argv_lookup->{ '?' } = $argv_lookup->{ h };
$argv_lookup = { map{ "-".$_ => $argv_lookup->{ $_ } } keys %$argv_lookup };
my $argv_ref_lookup = { SCALAR => subname( 'argv_scalar_lookup' => sub{ ${ shift @_ } = shift @ARGV; } ),
    ARRAY => subname( argv_hash_lookup => sub{ my $a = shift; ${ $a->[ 0 ] } = $a->[ 1 ]; } ),
    CODE => subname( argv_code_lookup => sub{ &{ shift @_ } } ),
};
print_help_exit unless scalar @ARGV;
while( my $arg0 = shift @ARGV ){
  if( defined( $argv_lookup->{ $arg0 } ) ){
    my $val = $argv_lookup->{ $arg0 };
    if( $val ){
      my $arg0_ref = ref $val;
      if( $arg0_ref ){
        $argv_ref_lookup ->{ $arg0_ref }->( $val );
      }
    }
  }
}

BEGIN{
  $ENV{FCGI_SOCKET_PATH} = "/tmp/spawner.sock" unless defined $ENV{FCGI_SOCKET_PATH};
  if( grep { '-e' eq $_  } @ARGV ){
    my $cref = sub{
      if( 'FCGI::ProcManager' eq scalar caller ){
        CORE::exit @_;
      } else {
        if( $^V lt v5.12.0 ){
          no warnings;
          last CALLED_OUT;
        } else {
          goto CALLED_OUT;
        }
      }
    };
    if( $^V lt v5.12.0 ){
      *CORE::GLOBAL::exit = $cref;
      my $rv = *CORE::GLOBAL::exit;
    } else {
      *main::exit = $cref;
    }
  }
}

if( $redefine_exit ){
  use subs qw/exit/ ;
}



defined( my $pid = fork ) or croak "Forking logger: $!";
if( $pid ){
  if( defined $pid_file ){
    open( my $pid_fh, ">", $pid_file ) or croak "Writing $pid_file: $!";
    print $pid_fh "$pid"; close $pid_fh;
  }
  if( $no_detach ){
    map{ my $signal = $_; $SIG{ $signal } = subname( 'signal_handler' => sub{
                                                $signal = ( $signal eq 'INT' ) ? 'TERM' : $signal ;
                                                kill $signal => $pid ;
                                              } );
    } qw/INT HUP TERM/;
    my $rv = waitpid $pid => 0;
  }
  CORE::exit;
}


unless( $no_detach ){
  re_open_log $log_file;
  $SIG{ USR1 } = subname( 're_open_log_file' => sub{ re_open_log( $log_file ); }, );
}

my $conf_class = "FCGI::Spawn::ConfigFile";
if( $conf_moose ){ $conf_class .= "::Moose";
  croak "$@ $!" unless eval { require FCGI::Spawn::ConfigFile::Moose;
    FCGI::Spawn::ConfigFile::Moose->import; 1; }
} else {
  croak "$@ $!" unless eval { require FCGI::Spawn::ConfigFile;
    FCGI::Spawn::ConfigFile->import; 1; }
}
my $conf = $conf_class -> new();
my $gid = getgrnam( $group ); croak "Get ( probably non-existent ) group $group: $!" if $gid == 0;
my $uid = getpwnam( $user );  croak "Get ( probably non-existent ) user $user: $!" if $uid == 0;

my( $shared, $ipc ); $shared={};

if( $time_limit ){
  make_shared( [ $shared => \$ipc, ] => # $shared is a ref, too (HashRef)
      { 'mm_size' => $mm_size, 'mm_file' => $mm_file, 'uid' => $uid, },
  );
  $conf->set_pid_callouts( $shared );
  $conf->set_time_limit( $time_limit );
}
$conf->set_sock_name( $ENV{FCGI_SOCKET_PATH} );

defined( my $spawn_pid = fork ) or croak "Forking spawn: $!";
if( $spawn_pid ){
  #$SIG{ CHLD } = 'IGNORE';
  map{ my $signal = $_; $SIG{ $signal } = sig_handle( $signal => $spawn_pid );
  } qw/INT HUP TERM/;
  $0 = 'fcgi_spawn';
  if( $time_limit ){
    my $pid_callouts = $conf->get_pid_callouts;
    my %pids_sent = ();
    until( is_process_dead( $spawn_pid ) ){ # while spawn_pid is running; it's auto-buried then
      foreach my $pid ( keys %$pid_callouts){
        my $longtitude = time - $pid_callouts->{ $pid };
        if( $longtitude >= $time_limit and not defined $pids_sent{ $pid } ){
          if( $soft_tl ){
            kill 'TERM' => $pid;
            $pids_sent{ $pid } = 'TERM' unless is_process_dead( $pid, );
          } else {
            kill( 'KILL' => $pid ) unless is_process_dead( $pid, );
            $pids_sent{ $pid } = 'KILL';
          }
        }
      }
      while( my( $pid => $sig_sent, ) = each( %pids_sent ) ){
        if( defined( $$pid_callouts{ $pid } ) ){
          if( $soft_tl and ( 'TERM' eq $sig_sent ) ){
            unless( is_process_dead( $pid ) ){
              my $seconds = time - $$pid_callouts{ $pid };
              if( $seconds > $soft_tl ){
                kill( 'KILL' => $pid ) unless is_process_dead( $pid, );
                $pids_sent{ $pid } = 'KILL';
              }
            }
          }
          if( is_process_dead( $pid, ) ){
            delete $$pid_callouts{ $pid };
            delete $pids_sent{ $pid };
          }
        }
      }
      sleep 1;
    }
  }
  waitpid $spawn_pid => 0; # while spawn_pid is running
  unlink $pid_file if defined $pid_file; # fork is reaped already
  if( $time_limit and defined $mm_file ){ # fork is reaped already
    my $rv = ( -f $mm_file ) ? unlink $mm_file : 1;
    my $sem_file = "$mm_file.sem";
    my $sem_rv = ( -f $sem_file ) ? unlink $sem_file : 1;
    my $msg =  '';
    $msg .= "Can not delete $mm_file" unless $rv;
    $msg .=  " Can not delete $sem_file" unless $sem_rv;
    croak( $msg ) unless( $rv and $sem_rv );
  }
  CORE::exit;
}

%ENV=();

$conf->read_fsp_config_file( $config_path );

eval { require FCGI::Spawn; FCGI::Spawn->import;
1; } or croak $!;

my $spawn = FCGI::Spawn->new( $conf, )
  or croak "$@ $!";

if( defined( $conf->get_chroot_path ) ){
  chroot( $conf->get_chroot_path ) or croak "$@ $!";
}

setgid( $gid ); $) = "$gid $gid"; $( = $gid; croak "Set group $group($gid): $!" if ( $( != $gid ) or ( $) != $gid );
setuid( $uid ); $> = $uid; $< = $uid; croak "Set user $user($uid): $!" if ( $< != $uid ) or ( $> != $uid );

setsid or croak "Setting session: $!";

my $preloaders = { nonprepared => [], prepared => [], };
if( $preload ){
  Apache::Fake->new if $spawn->{ mod_perl };
  opendir( my $preloaders_dh, $config_path ) or croak "Opening path $config_path: $!";
  while( my $fn = readdir $preloaders_dh ){
    next if grep { $_ eq $fn } qw/. ../;
    my $full_fn = join '/', $config_path, $fn;
    next unless -f $full_fn;
    push( @{ $preloaders->{ nonprepared  } }, $full_fn ) if $fn =~ /^preload_nonprepared_\d+\.pl$/;
    push( @{ $preloaders->{ prepared  } },     $full_fn ) if $fn =~ /^preload_prepared_\d+\.pl$/;
  }
  closedir $preloaders_dh;

  map{
    $preloaders->{ $_  } = [
      map{
        my $str = '';
        open( my $preloader_fh, "<", $_ ) or croak "Open $_: $!";
        while( <$preloader_fh> ){
          $str .= $_;
        }
        close $preloader_fh;
        $str;
      } sort {
        my( $anum, $bnum ) = map{
          my $c = $_; $c =~ s/[^\d]//g;
          $c;
        } ( $a, $b );
        $anum <=> $bnum;
      } @{ $preloaders->{ $_  } }
    ];
  } keys %$preloaders;

  map{ @{ $preloaders->{ $_ } } = sort @{ $preloaders->{ $_ } } ;
  } keys %$preloaders;
  map{
    # TBD: Try::Tiny
    eval "$_ ; 1;" ## no critic
    or croak "$_\n $@ $!";
  } @{ $preloaders->{ nonprepared } };

}

$spawn -> prepare;


if( $preload ){
  map{
      # TBD: Try::Tiny
      eval $_; ## no critic
      if( $@ ){
        warn "$@\nterminating PM pid $spawn_pid";
        kill 'TERM', $spawn_pid;
        waitpid $spawn_pid, 0;
        croak $@; # should not happen;
      }
  } @{ $preloaders->{ prepared } };
}

$spawn -> spawn;

1;
